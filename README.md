applyAjax.js
============

applyAjax - это библиотека включающая в себя js-шаблонизатор и обертку над $.ajax, упрощающую Ajax запросы к серверу.

##Шаблонизатор

Предположим вы желаете всунуть на сайт каталог товаров. В простейшем случае вам понадобится страница списка товаров и страница, собственно товара.

И так, вам надо сверстать 2 этих страницы, а затем расставить маркеры для шаблонизатора дабы он знал в какие места страницы нужно вставлять данные. 

Сейчас я как смогу поведаю суть работы шаблонизатора на примере этих страниц. Работа по поиску мест для вставки сводится к поиску определенных классов элемента в верстке, например элемент с классом *in_text_content* говорит о том что внутрь этого элемента нужно вставить содержимое поля данных content:

    <div class="in_text_content"></div>
    
    Код 1.
    
Разумеется, не так все просто. Давайте поподробнее разберем весь механизм. В виде данных шаблонизатору приходит массив данных, чаще всего выборка из базы данных, и формат у него соответствующий, то есть набор записей с однородным набором полей, например данные двух пользователя:

    var users = [{id: 34,
                  name: 'John',
                  surname: 'Smith',
                  birthdate: '01.04.1970'},
                 {id: 35,
                  name: 'Jane',
                  surname: 'Doe',
                  birthdate: '23.09.1983'}];
              
    Код 2.
    
Теперь допустим нам надо вставить данные о каждом пользователе в вот в такой блок верстки:

    <li class="in_id_id in_data-val_birthdate">
        <span class="in_text_surname"></span>
        <span class="in_text_name"></span>
    </li>
    
    Код 3.
    
То есть должен получиться список пользователей. 
Но в изначальном шаблоне будет что-то типа:

    <li class="clone in_id_id in_data-val_birthdate">
        <span class="in_text_surname"></span>
        <span class="in_text_name"></span>
    </li>
    
    Код 4.
    
Отличие в наличие класса *clone*, строго говоря, называться он может и по-другому, но его назначение крайне важно. Класс должен нести с собой стиль CSS делающий элемент с этим классом невидимым.

Назначение же его в том, чтобы отделять элементы для множественной ставки от элементов для единичной вставки. Разница между этими двумя типами в способе обработки данных с несколькими однородными записями: при единичной вставки шаблонизатору все равно сколько записей пришло а вход, он всегда оставляет только одну – первую, то есть если воспользовался предыдущим примером с юзерами, то при единичной вставке вставится только одна первая запись о пользователе John Smith, а вторая будет отброшена. При этом должен использоваться [Код 3] (без указать класса *clone*), то есть блок [Код 3] просто заполнится данными.

Если же используется множественная вставка то будут вставлены все записи и вот как это произойдет:

1.  Шаблонизатор скопирует эталонный блок верстки код 4 (с классом *clone*) и вставит после.

2.	Вставит первый кортеж данных в эту самую копию.

3.	Пункты 1 и 2 будут повторяться пока записи данных не закончатся.

Можно явно задать какой способ использовать: функция *setMultiData* работает по методу множественной вставки, а функция *setData* по методу единичной вставки, но я рекомендую использовать функцию *insertData*, ибо она избавляет от этого выбора - в этом случае выбор между двумя методами определяется наличием класса *HIDE\_CLASS* (он же *clone* из предыдущего примера, *HIDE_CLASS* имя константы определяющей имя этого ключевого класса), напомню что для верной работы этому классу должна соответствовать полная невидимость элемента его использующего.

<br>
##Описание методов

####isJSON

    function isJSON (str)
    
**Описание:**

Проверка и парсинг JSON-строки.

**Параметры:**

-   *str* – json-строка.

<br>
####request

    function request (params, async, type, callback, callbackError)
    
**Описание:**

Функция выполняющая Ajax-запрос к серверу, её параметры.

**Параметры:**

-   *params* – параметры запроса к серверу;

-   *async* – асинхронно ли выполнять запрос;

-   *type* – тип запроса, обычно GET или POST;

-   *callback* – колбэк на успешное выполнение запроса;

-   *callbackError* – колбэк на ошибочное выполнение.

На вход колбэку на успещное выполнение приходит результат запроса. Его можно вставляться в верстку при помощи функций шаблонизатора.

<br>
####setMultiData

    function setMultiData (data, parent)
    
**Описание:**

Запилить данные в шаблон. При этом исходные элементы для вставки остаются неизменными и становятся невидимыми, в том время как данные ставляются в их видимые копии, которые создаются перед вставкой.

**Параметры:**

-   *data* – данные для вставки;

-   *parent* - jQuery-селектор блоков для вставки

<br>
####setData

    function setData (data, parent)
    
**Описание:**

Запилить данные в шаблон. В отличие от предыдущей функции, здесь данные вставляются прямо в выбранные селектором элементы.

**Параметры:**

-   *data* – данные для вставки;

-   *parent* - jQuery-селектор блоков для вставки

<br>
####insertData

    function insertData(data, parent)
    
**Описание:**

Использовать один из двух предудущих методов вставки изходя из присутствия в старших тегах блоков для вставки класса, отвечающего за сокрытие эталонных блоков (HIDE_CLASS).

**Параметры:**

-   *data* – данные для вставки;

-   *parent* - jQuery-селектор блоков для вставки
